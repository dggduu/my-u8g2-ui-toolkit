#include "Delay.h"
#include "math.h"
#include "stm32f10x.h"
#include "string.h"
#include "u8g2.h"
#include "u8x8.h"
#include "stm32f10x_i2c.h"




#define SCL_Pin GPIO_Pin_8
#define SDA_Pin GPIO_Pin_9                                             
#define IIC_GPIO_Port GPIOB

#define SW_IIC 0

void IIC_Init(void) {
	if (SW_IIC == 1) {
		GPIO_InitTypeDef GPIO_InitStructure;
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

		GPIO_InitStructure.GPIO_Pin = SCL_Pin | SDA_Pin;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_Init(IIC_GPIO_Port, &GPIO_InitStructure);
		
	} else {
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
		GPIO_InitTypeDef GPIO_InitStructure;
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
		
		
		I2C_InitTypeDef IIC_InitStructure;
		IIC_InitStructure.I2C_Ack = I2C_Ack_Enable;
		IIC_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
		IIC_InitStructure.I2C_ClockSpeed = 400000;
		IIC_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
		IIC_InitStructure.I2C_Mode = I2C_Mode_I2C;
		IIC_InitStructure.I2C_OwnAddress1 = 0x00;
		I2C_Init(I2C1, &IIC_InitStructure);
		I2C_Cmd(I2C1, ENABLE);
	}
}


uint8_t u8x8_byte_stm32_hw_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    static uint8_t buffer[32];
    static uint8_t buf_idx;
    uint8_t *data = (uint8_t *)arg_ptr;
    
    switch(msg)
    {
        case U8X8_MSG_BYTE_SEND:
            for(uint8_t i=0; i<arg_int; i++)
            {
                buffer[buf_idx++] = data[i];
            }
            break;
        
        case U8X8_MSG_BYTE_INIT:
            break;
        
        case U8X8_MSG_BYTE_SET_DC:
            break;
        
        case U8X8_MSG_BYTE_START_TRANSFER:
            buf_idx = 0;
            break;
        
        case U8X8_MSG_BYTE_END_TRANSFER:
            if(buf_idx > 0)
            {
                while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY));
                I2C_GenerateSTART(I2C1, ENABLE);
                while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
                
                I2C_Send7bitAddress(I2C1, 0x78, I2C_Direction_Transmitter);
                while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
                for(uint8_t i=0; i<buf_idx; i++)
                {
                    I2C_SendData(I2C1, buffer[i]);
                    while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
                }
                I2C_GenerateSTOP(I2C1, ENABLE);
                buf_idx = 0;
            }
            break;
        
        default:
            return 0;
    }
    return 1;
}

uint8_t u8x8_gpio_and_delay_stm32(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch(msg)
    {
        case U8X8_MSG_DELAY_100NANO:
            __NOP();
            break;
        
        case U8X8_MSG_DELAY_10MICRO: 
            for(uint16_t i=0; i<160; i++);
            break;
        
        case U8X8_MSG_DELAY_MILLI:
            for(uint32_t i=0; i<arg_int*1000; i++);
            break;
        
        case U8X8_MSG_DELAY_I2C:
            __NOP();
            break;
        
        case U8X8_MSG_GPIO_I2C_CLOCK:
        case U8X8_MSG_GPIO_I2C_DATA:
        case U8X8_MSG_GPIO_CS:
        case U8X8_MSG_GPIO_DC:
        case U8X8_MSG_GPIO_RESET:
            break;
    }
    return 1;
}


uint8_t u8x8_gpio_and_delay(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int,
                            void *arg_ptr) {
  switch (msg) {
  case U8X8_MSG_DELAY_100NANO:
    __NOP();
    break;
  case U8X8_MSG_DELAY_10MICRO:
    for (uint16_t n = 0; n < 320; n++) {
      __NOP();
    }
    break;
  case U8X8_MSG_DELAY_MILLI:
    Delay_ms(1);
    break;
  case U8X8_MSG_DELAY_I2C:
    Delay_us(5);
    break;
  case U8X8_MSG_GPIO_I2C_CLOCK:
    arg_int ? GPIO_SetBits(IIC_GPIO_Port, SCL_Pin)
            : GPIO_ResetBits(IIC_GPIO_Port, SCL_Pin);
    break;
  case U8X8_MSG_GPIO_I2C_DATA:
    arg_int ? GPIO_SetBits(IIC_GPIO_Port, SDA_Pin)
            : GPIO_ResetBits(IIC_GPIO_Port, SDA_Pin);
    break;
  default:
    u8x8_SetGPIOResult(u8x8, 1);
    break;
  }
  return 1;
}

void u8g2Init(u8g2_t *u8g2) {
	if(SW_IIC == 1) {
		  u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2, U8G2_R0, u8x8_byte_sw_i2c, u8x8_gpio_and_delay);
	}else {
		u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2, U8G2_R0, u8x8_byte_stm32_hw_i2c, u8x8_gpio_and_delay_stm32);
	}
  u8g2_InitDisplay(u8g2);
  u8g2_SetPowerSave(u8g2, 0);
  u8g2_ClearBuffer(u8g2);
}


void my_draw(u8g2_t *u8g2, uint8_t code) {
}

// 35x35icon
const uint8_t icon_list[][128] = {

0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0xFC,0xFF,0xFF,0xDF,0xFB,0xFF,
0xFF,0xEF,0xF7,0xFF,0xFF,0xF3,0xCF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFE,0x7F,0xFF,
0x3F,0xFF,0xFF,0xFC,0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFD,
0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFD,0xBF,0x1F,0xF8,0xFD,0xBF,0xDF,0xFB,0xFD,
0xBF,0xDF,0xFB,0xFD,0xBF,0xDF,0xFB,0xFD,0xBF,0xDF,0xFB,0xFD,0xBF,0xDF,0xFB,0xFD,
0xBF,0xDF,0xFB,0xFD,0xBF,0xDF,0xFB,0xFD,0x3F,0xC0,0x03,0xFC,0x3F,0xC0,0x03,0xFC,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
	
	
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0x03,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xFF,0xFF,0xF7,
0xCF,0x03,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xCF,0x03,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
	
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xFE,0xFF,
0xFF,0x7F,0xFE,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFE,0xFF,
0xBF,0xFF,0xFE,0xFD,0xFF,0xFF,0xFE,0xFF,0xDF,0xFF,0xFE,0xFB,0xFF,0xFF,0xFE,0xFF,
0xEF,0xFF,0xFE,0xF7,0xF7,0xFF,0xFE,0xEF,0xF7,0xFF,0xFE,0xEF,0xF7,0x7F,0xFE,0xEF,
0xF7,0xFF,0xFE,0xEF,0xF7,0xFF,0xFF,0xEF,0xF7,0xFF,0xFF,0xEF,0xEF,0xFF,0xFF,0xF7,
0xFF,0xFF,0xFF,0xFF,0xDF,0xFF,0xFF,0xFB,0xFF,0xFF,0xFF,0xFF,0xBF,0xFF,0xFF,0xFD,
0x7F,0xFF,0xFF,0xFE,0xFF,0xFE,0x7F,0xFF,0xFF,0xF1,0x8F,0xFF,0xFF,0xEF,0xF7,0xFF,
0xFF,0x1F,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x1F,0x00,
		0x00,0x38,0x10,0x00,0x00,0x42,0x10,0x00,0x00,0x42,0x10,0x00,0x00,0xF2,0x17,0x00,
		0x00,0x42,0x0C,0x00,0x00,0x42,0x00,0x00,0x00,0x42,0xF0,0x00,0x00,0xC0,0x0F,0x00,
		0x00,0xFF,0x7F,0x00,0x00,0x1C,0x02,0x00,0xE0,0x07,0x02,0x00,0x00,0x02,0x02,0x00,
		0x00,0x02,0x02,0x00,0x00,0x02,0x02,0x00,0x00,0x02,0x02,0x00,0x00,0x02,0x02,0x00,
		0x00,0x03,0x02,0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	}; 
